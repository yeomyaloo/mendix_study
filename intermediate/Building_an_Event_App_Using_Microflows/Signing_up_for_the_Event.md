# 학습목표
이 모듈이 끝나면 다음을 수행할 수 있습니다:
- Mendix Studio Pro에서 익명 사용자 관리하기
- 마이크로플로우에서 작업할 수 있는 변수의 종류와 그 기능 나열하기
- 마이크로플로우 표현식을 만들 때 함수 사용 방법 설명하기
- 익명 사용자가 앱의 일부를 사용할 수 있도록 허용하기
- 마이크로플로우 표현식 사용하기
- 마이크로플로우 디버거 사용하기
- 객체 롤백하기

# 이벤트 등록 활성화
## 1. 시나리오
- 이전 모듈에서 멋진 프로그램을 만들었으니, 이제 이를 세상과 공유할 시간입니다!  
- 모두가 이 이벤트를 위해 준비된 놀라운 프로그램을 볼 수 있는 웹사이트나 앱에 방문할 수 있다면 얼마나 멋질까요?
- 관심이 있는 사람들은 이용 가능한 티켓 중에서 선택하고 계정을 등록하면서 티켓을 구매할 수 있습니다.
  - 이 기능을 익명 사용자를 추가하고 티켓 구매 프로세스를 설정하여 구현할 것입니다.

# 익명 사용자, 변수 및 함수(Anonymous Users, Variables, and Functions)
## 1. 익명 사용자(Anonymous user)
```plaintext
Mendix에서 라이선스 환경을 위해 앱을 만들 때, 실행하기 전에 보안 설정을 프로덕션 모드로 전환해야 합니다.
이로 인해 사용자는 로그인 페이지 이외의 내용을 보려면 앱에 로그인해야 합니다.

하지만 온라인 상점처럼 로그인할 필요 없는 콘텐츠를 어떻게 보여줄 수 있을까요? 이를 위해 Mendix는 익명 사용자를 제공합니다.
익명 사용자를 통해 로그인하지 않은 사용자에게 페이지를 표시하고 접근 권한을 부여할 수 있습니다.
상품을 보여주는 것뿐만 아니라 비밀번호 재설정이나 뉴스레터 구독과 같은 유용한 프로세스도 고려해야 합니다.

익명 사용자를 활성화하는 설정은 Mendix Studio Pro의 앱 보안에서 익명 사용자 탭 아래에서 찾을 수 있습니다.
여기에서 익명 사용자를 나타내는 사용자 역할도 선택할 수 있습니다.
이 방식으로 로그인할 수 있는 사용자 역할과 동일하게 보안을 구성할 수 있습니다.

익명 사용자를 활성화한 후에는 익명 사용자 역할을 위한 역할 기반 홈페이지를 추가해야 합니다.
이로 인해 지정된 URL로 가는 모든 사용자의 랜딩 페이지가 로그인 페이지에서 설계된 익명 페이지로 변경됩니다.
익명 사용자 역할은 앱의 다른 사용자 역할과 동일하게 구성할 수 있지만, 앱을 방문하는 모든 사용자에게 자동으로 할당되므로 이 역할의 보안 구성에 특별히 주의해야 합니다. 익명 사용자와 관련 없는 엔터티나 프로세스에 접근할 수 있도록 해서는 안 됩니다.
```

## 2. 변수(Variables)
Mendix에서 마이크로플로우를 만들 때, 많은 경우 변수를 사용하게 됩니다. 변수는 단일 객체, 객체 목록 또는 기본(단일) 값으로 존재할 수 있습니다.
### 2.1 변수의 종류
마이크로플로우 내에서 작업할 수 있는 데이터 유형은 다음과 같습니다:
- **객체**: 도메인 모델의 엔터티에 의해 정의된 엔터티의 단일 인스턴스
  - 생성, 변경, 삭제
  - 목적 – 데이터 저장
- **객체 목록**: 특정 엔터티의 객체 목록
  - 생성, 변경(설정, 추가)
  - 목록 함수
    - 목록 집계(합계, 평균, 개수, 최소, 최대)
    - 목록 연산(합집합, 교집합, 차집합, 포함, 동등, 정렬, 필터, 찾기, 머리, 꼬리)
  - 목적 – 객체 목록으로 작업 수행
- **기본 변수**: 다양한 값 유형을 가질 수 있음: Boolean, 날짜 및 시간, 십진수, 열거형, 정수/롱, 문자열
  - 목적 – 마이크로플로우 로직 내에서 값의 임시 저장(예: 값 추적 또는 목록을 반복한 횟수 세기)

| Variable Type         | Definition                                                                 | Operations                          | Purpose                                                           | List Functions                                                       |
|-----------------------|---------------------------------------------------------------------------|-------------------------------------|-------------------------------------------------------------------|---------------------------------------------------------------------|
| **Object**            | A single instance of an entity, defined by an entity in the domain model | Create, change, delete             | Store data                                                        |                                                                     |
| **List of Objects**   | A list of the objects of a specific entity                               | Create, change (set, add)         | Do something with the list of objects                             | Aggregate a list: sum, average, count, minimum, maximum           |
|                       |                                                                           |                                     |                                                                   | List operations: union, intersect, subtract, contains, equals, sort, filter, find, head, tail |
| **Primitive Variables**| Can be of different value types: Boolean, date and time, decimal, enumeration, integer/long, string |                                     | Temporary storage of values for use within microflow logic (e.g., for keeping track of a value or counting the times you’ve iterated over a list) |                                                                     |
### 2.2 변수 표현 방법
- 마이크로플로우 내에서 변수는 달러 기호(`$`)로 표시되며, 변수 이름이 뒤따릅니다.
- 변수는 입력 매개변수로 또는 검색 활동을 통해 검색하여 마이크로플로우에 삽입할 수 있습니다.
  - 변수는 마이크로플로우의 출력 값(반환 값)으로도 사용될 수 있습니다.

## 3. 토큰(Tokens)
- 토큰은 `특별한 유형의 변수`입니다.
- 토큰은 마이크로플로우에서 사용할 수 있는 시스템 생성 값으로, 예를 들어 결정 또는 XPath 제약 조건에서 사용됩니다.
- System generated value

### 3.1 토큰의 특징
- 여러 가지 토큰이 있으며, 대부분은 날짜 및 시간과 관련이 있습니다. 이러한 날짜 및 시간 토큰은 정확히 지정된 순간을 포함합니다. 시간대와 UTC의 시간 차이에 주의해야 합니다(날짜 및 시간 관련 정보는 Mendix 참조 가이드의 날짜 및 시간 처리 FAQ를 참조하세요).
- 날짜 및 시간과 관련이 없는 토큰으로는 현재 사용자 토큰, 현재 객체 토큰 및 사용자 역할 토큰이 있습니다. 현재 사용자에는 현재 사용자 객체의 ID가 포함됩니다. 예를 들어, 현재 순간(밀리초 단위로 정확함)은 ‘[%CurrentDateTime%]’를 사용하여 식별할 수 있으며, 현재 사용자 ID는 ‘[%CurrentUser%]’를 사용하여 접근할 수 있습니다.

## 4. 마이크로플로우 표현식 및 함수(Microflow expressions and functions)
- 마이크로플로우 표현식은 비즈니스 프로세스 내에서 로직을 정의하는 데 도움을 줍니다.
- 마이크로플로우 표현식은 마이크로플로우 및 규칙에서 사용할 수 있습니다.
### 4.1 마이크로플로우 표현식 종류
표현식을 사용할 수 있는 다양한 영역의 예는 다음과 같습니다:
- 조건 분기
- 객체 생성 및 변경 작업
- 변수 생성 및 변경
- 종료 이벤트의 출력
- 매개변수의 인수(Java 작업, 서브 마이크로플로우 호출 등)
이러한 표현식 내에서 객체나 변수를 접근, 평가, 형식화 및 조작하는 데 사용할 수 있습니다.

## 5. 구성 요소(Components)
표현식은 여러 가지 다른 유형의 구성 요소로 구성됩니다. 작업할 수 있는 변수의 다양한 유형은 객체, 속성 및 연관관계입니다.
- **객체 (평가)**: 
  - `$Customer != empty`
- **속성 (값 설정)**: 
  - `$Customer/Address`
- **연관관계 (평가)**: 
  - `$Customer/OrderManagement.Customer_ProfileImage != empty`

## 6. 함수(Functions)
마이크로플로우 표현식을 만들 때 사용할 수 있는 많은 미리 정의된 함수(f(x))가 있습니다. 아래는 몇 가지 예입니다.
- **산술 표현식(Arithmetic Expressions)**: `* div + -`
- **관계 표현식(Relational Expressions)**: `< > = !=`
- **특별 체크(Special Checks)**: `empty, isNew`
- **불리언 표현식(Boolean Expressions)**: `and, or, not`
- **차별화(Differentiation)**: `if, then, else`
- **수학(Mathematical)**: `max, min, round` 등
- **문자열(String)**: `toUpperCase, find, substring` 등
- **날짜/시간(Date/Time)**: `dateTime, addDays` 등
- **파싱/형식화(Parse/Format)**: `parseFloat, formatDateTime` 등

사용 가능한 표현식과 함수에 대한 개요 및 사용 방법에 대한 세부정보는 Mendix 참조 가이드의 마이크로플로우 표현식에서 확인하세요.

## 7. 함수 결합(Mathematical)
- 많은 경우 원하는 결과를 얻기 위해 여러 함수를 결합해야 합니다.
- 이 경우 계산의 우선순위를 결정하기 위해 괄호를 사용할 수 있습니다.

```plaintext
첫 번째 예에서는 기본 가격 및 할인 속성을 기반으로 판매 가격을 계산합니다 (OCH_SetLineValue 마이크로플로우에서):
`$CurrentPrice/Price - (($CurrentPrice/Price div 100) * $OrderLine/Discount)`
여기서 산술 함수(뺄셈, 나누기 및 곱하기)가 결합되고 있습니다.
```

다음 예제는 주문이 배치된 요일을 결정하고 이 요일을 숫자 값(예: 월요일은 "1", 목요일은 "4")으로 출력합니다:

## 8. 여러 단계를 사용하여 함수 결합
가독성과 로직을 위해 원하는 결과에 도달하기 위해 별도의 단계로 작업해야 할 때가 있습니다. 이 경우 변수를 생성하고 초기 값을 설정한 다음, 해당 변수를 후속 마이크로플로우 작업에서 사용할 수 있습니다.

## 9. 날짜/시간 함수
날짜 및 시간 작업은 많은 애플리케이션에서 발생하는 일입니다. 표현식을 생성하기 위해 사용할 수 있는 많은 함수가 날짜 및 시간과 관련이 있습니다.
### 9.1 Date/Time 함수 종류
일반적인 날짜/시간(=Date/Time) 함수는 다음과 같습니다:
- 날짜 간 호출
- 날짜 추가 호출
- 날짜로 잘라내기 호출
- 형식화 및 파싱
### 9.2 추가적으로 사용되는 Date/Time 함수
Mendix에서 사용하는 형식과 다른 형식으로 날짜/시간 입력(또는 출력)이 있는 경우 형식화 및 파싱을 사용할 수 있습니다. 예를 들어 다른 시스템에서 날짜를 가져오거나 문자열로 날짜 값을 표시하는 상황이 있습니다.

### 9.3 Formatting and Parsing (형식화와 파싱)
형식화는 날짜를 텍스트로 변환하는 것이고, 파싱은 텍스트를 날짜로 변환하는 것입니다. 이러한 상황에 대한 함수는 `formatDateTime` 및 `parseDateTime`입니다. 이러한 함수에 사용할 수 있는 패턴은 `SimpleDateFormat`을 따릅니다.

## 10. 필수 추가 읽기
시간대, 지역화 및 일광 절약 시간과 같은 주제는 날짜/시간 기반 로직을 매우 복잡하게 만들 수 있으며, 그 영향을 인식해야 합니다. 이러한 주제에 대한 필수 정보는 Mendix 참조 가이드의 날짜 및 시간 처리 FAQ를 참조하세요.

# 로그인 없이 등록 허용하기
### 시나리오
- 이전 모듈에서는 서브 마이크로플로우, 규칙 및 주석을 사용하여 로직을 재사용 가능하고 구조적으로 만드는 방법을 배웠습니다.
- 이제 우리는 청중을 위한 프로그램을 추가하고 사람들이 로그인하지 않고도 이 프로그램을 볼 수 있도록 익명 기능을 활용할 것입니다.
- 만약 이 사람이 관심을 가지게 된다면, 우리는 이 사람이 등록하도록 유도하고, 표현식을 통해 이 가입을 검증할 것입니다.
- 구독 과정에서 우리의 로직에 빠뜨린 것이 있었고, 이를 마이크로플로우 디버거를 사용하여 해결할 것입니다.

## 1. 익명 사용자 역할 생성하기(Creating an Anonymous User Role)
1. 앱 보안에서 "Anonymous"라는 사용자 역할을 생성합니다.  
2. 익명 사용자 탭으로 가서 "Allow anonymous users"를 "Yes"로 설정하고, 방금 생성한 사용자 역할을 익명 사용자 역할로 선택합니다.
![image](https://github.com/user-attachments/assets/d18c52a3-b6f3-406c-ac7f-fe88b6100bce)

## 2. 익명 사용자가 프로그램을 확인합니다
### 2.1 시나리오
홈페이지가 꽤 비어 보이므로 약간의 내용을 추가하고 싶습니다. 빌딩 블록을 선택하여 이를 수행할 수 있습니다.

### 2.1 내용 추가 방법
1. 카드 빌딩 블록을 선택하고 두 번째 레이아웃 그리드에 배치합니다.
![image](https://github.com/user-attachments/assets/1a8cdc0d-992b-469d-9a18-75e75d2dbbe0)
2. 첫 번째 카드는 이벤트 프로그램을 찾는 곳이 될 것입니다. 캡션에 적절한 이름을 지정해 "Program"으로 설정하여 익명 사용자가 이 버튼을 쉽게 식별할 수 있도록 합니다.
3. 이제 컨테이너에 새로운 페이지를 연결합니다. "Open page" 버튼을 추가하고 "New"를 선택하여 새 페이지를 생성한 후 "Program_Overview_Anonymous"라는 이름을 지정합니다. 올바른 레이아웃(Atlas_Default)을 선택하고 빈 템플릿을 사용합니다.
4. 이 새로운 페이지를 다음과 같이 설정합니다:
  - 이미 페이지에 있는 LayoutGrid에 PageHeader 빌딩 블록을 추가합니다.
  - 아래에 LayoutGrid를 추가하고 Timeline 위젯으로 채웁니다.
  - Page header 제목 텍스트를 "Program"으로 변경합니다.
  - Supporting text를 "Details of the program"으로 변경합니다.
  ![image](https://github.com/user-attachments/assets/92acd317-b0a1-4763-862d-aeaa3c4e581f)
5. Timeline에서는 ProgramItem 엔터티를 데이터 소스로 선택하고 정렬 순서를 StartTime(오름차순)으로 설정합니다.
- 데이터 소스 탭에서 Title, Description, Time Indication을 다음에 맞게 수정합니다:
![image](https://github.com/user-attachments/assets/82fe182e-e0ce-4e9f-be0f-95eb093957ba)
6. 일반 탭에서 Group Events를 활성화하고 Group by Day를 선택하여 Day 엔터티의 StartDate를 Group Attribute로 설정합니다.
  ![image](https://github.com/user-attachments/assets/030806c8-baa0-410a-9d97-6346505bcc0b)
7. 익명 모듈 역할을 허용된 역할로 선택하여 그들이 프로그램 페이지를 볼 수 있도록 합니다.
8. 예상하셨겠지만, 오류 도크에 많은 오류가 있습니다. EventManagement 모듈 보안을 업데이트하고 프로그램 페이지에 표시된 정보에 대한 읽기 액세스만 추가하여 오류를 수정합니다.

### 2.2 다음 계획
- 이제 익명 사용자가 프로그램을 볼 수 있는 페이지를 생성했습니다. 다음에는 그들이 구매할 수 있는 티켓을 생성할 것입니다.

## 3. 사용 가능한 티켓 생성하기
### 3.1 시나리오
- 이제 사람들이 우리의 관심을 끌었으므로, 티켓을 구매할 수 있는 옵션을 제공하고자 합니다.
- 여러 날 동안 다양한 아티스트가 공연할 예정이므로, 사람들은 가장 좋아하는 날에 참석할 수 있어야 합니다.
- 또한, 축제 하루에 참석할 수 있는 최대 인원을 설정했습니다. 따라서 서로 다른 티켓 중에서 선택할 수 있도록 하고자 합니다.

### 3.2 도메인 모델 생성
- 서로 다른 티켓을 설정하기 위해 Ticket 엔터티를 생성합니다. (도메인 모델에 새 엔터티를 추가하세요.)
#### Ticket Entity Attribute
- Ticket에는 Description (String), Price (Decimal), NumberOfDays (Enumeration)를 등록합니다. Enumeration (ENU_NumberOfDays)을 생성하고 1, 2, 3의 세 가지 값을 부여합니다. 
#### Ticket Entity Association
- Ticket은 Day에 대한 참조를 가지며, 이 관계는 Ticket이 소유자인 다대다(many to many | * - *) 관계입니다. 즉, Ticket 측에서 관계를 설정할 수 있습니다.  
- 아직 접근 규칙은 설정하지 마세요. Mendix Studio Pro가 이를 요구할 때 설정하겠습니다.  
#### create Ticket Entity overview page 
- 이제 Ticket 엔터티에 대한 개요 페이지를 생성하고, 내비게이션에 개요 페이지를 추가한 후 생성한 페이지의 허용 역할을 설정합니다.
- 이 경우에는 EventManager만 접근할 수 있습니다.
- Ticket_NewEdit 페이지에서 관련 날짜를 선택할 수 있는지 확인하고, 그렇지 않은 경우 Input reference set selector를 추가하여 직접 추가합니다.  
  - Input reference set selector를 위해 "Day_Select"라는 새 페이지를 생성합니다.
  - 템플릿으로 "Select With Data Grid"를 선택합니다.
  - Input reference selector를 Ticket_Day > Day > StartDate 속성과 연결합니다.  

### 3.3 보안 문제 해결
이제 Mendix Studio Pro가 보안 문제에 대해 알림을 제공합니다. 이를 해결하세요.
#### Add Before Commit Event
유효한 티켓을 입력하기 위해, commit 이전 이벤트를 설정해야 합니다. commit 이전 이벤트를 추가하고 다음을 검증하는 마이크로플로우를 생성하세요:
- Description이 채워졌는지
- Price가 채워졌는지
- Number of days가 선택되었는지
- 실제 날짜가 선택되었는지

### 3.4 최종 결과 화면
최종 결과는 다음과 같을 것입니다:
![image](https://github.com/user-attachments/assets/0b6671bf-4b6b-4c5c-a0b0-7c59b338d0e2)

## 4. 익명 사용자가 등록하기
### 4.1 시나리오
- 이제 티켓이 준비되었으므로 사람들이 티켓을 구매할 수 있는 프로세스를 생성할 수 있습니다.
- 우리는 그들에게 이름, 성, 생년월일, 이메일 주소, 뉴스레터 수신 여부, 계정 비밀번호 및 구매하고자 하는 티켓을 요청하고자 합니다.
### 4.2 구현
#### 4.2.1 도메인 모델 추가
- 이를 위해 `Registration`과 `Visitor` 엔터티를 도메인 모델에 추가
### 4.2.2 연관관계 추가
-   Ticket과 Visitor 간의 참조를 추가합니다. 아래의 표를 참조하세요.

### 4.3 도메인 모델
#### 4.3.1 Visitor
- Visitor 엔터티는 Administration 모듈의 Domain Model에 위치한 Account 엔터티의 일반화로 설정되어야 합니다.
![image](https://github.com/user-attachments/assets/00947724-3108-4b61-9b68-581ddd6f9118)
![image](https://github.com/user-attachments/assets/6b0f4663-0a2c-43cf-9cba-80e714793bfd)

#### 4.3.2 Registration
![image](https://github.com/user-attachments/assets/4ce1103b-b066-4c65-a126-718d0489fec4)
![image](https://github.com/user-attachments/assets/f9213336-371d-452e-b1c7-931ccf8577f1)
1. 익명 홈페이지로 이동하여 사용자가 등록 옵션을 찾을 수 있는 장소로 설정합니다. 두 번째 레이아웃 그리드에 두 번째 열을 추가하여 홈페이지에 2개의 섹션을 만듭니다. 레이아웃 그리드를 선택하고 오른쪽에 새 열을 추가합니다. 새 열에 Card 빌딩 블록을 추가하고 텍스트를 "Sign up"으로 변경합니다.
2. 컨테이너에서 새로운 마이크로플로우를 생성하여 클릭 시 마이크로플로우를 호출하도록 변경하고, 적절한 이름(예: ACT_Registration_StartSignUp)으로 설정합니다. 

### 4.4 등록 전 사전 작업
등록을 시작하기 전에, 사용자가 티켓을 사용할 수 있을 때만 이 작업을 시작할 수 있도록 해야 합니다. 그렇지 않으면, 티켓이 없다고 알려주기 위해 프로세스를 시작할 수 있는 것은 이상할 것입니다.
객체를 커밋하기 전에 유효성 검사 마이크로플로우를 사용한 것처럼, 프로세스를 시작하기 전에 이러한 원칙을 사용하는 것도 가능합니다. 여기서 유일한 차이점은 프로세스를 시작하기 위한 전제 조건을 설정한다는 것입니다. 즉, 방금 생성한 객체를 검증하는 것이 아니라 앱에 이미 저장된 정보를 검증합니다. 유효성 검사를 만들기 위해 마이크로플로우의 첫 번째 독점 분기에서 규칙을 사용합니다.
  1. `VAL_Ticket_CheckIfAvailable` 규칙을 생성합니다.
  2. EventInformation 엔터티에 하루 최대 허용 인원 수가 저장되어 있습니다. 따라서 첫 번째 EventInformation 객체를 검색해야 합니다. 이전에 한 번만 있을 수 있다고 결정했습니다.
  3. 다음 단계는 날짜 목록을 가져오는 것입니다. 그런 다음, 티켓이 사용 가능한 날짜가 있는지 추적하는 Boolean 유형의 변수를 가져와 초기값을 false로 설정합니다.
  4. 발견된 날짜를 반복하기 위해 루프를 사용합니다. 각 반복에서 해당 날짜에 구매한 티켓 수를 확인하고 하루 최대 사용자 수와 비교합니다. Xpath를 사용하여 티켓을 구매한 Visitor를 검색해야 합니다. Xpath는 다음과 같습니다: `[EventManagement.Visitor_Ticket/EventManagement.Ticket/EventManagement.Ticket_Day = $IteratorDay]`. 이를 집계 리스트 활동을 사용하여 세어봅니다. 결과 수는 최대값과 비교하고자 합니다.
  5. 남은 자리가 있다면 변수를 true로 변경하고, break 이벤트를 사용하여 반복을 종료합니다. 이는 최소한 하나의 날짜를 제공할 수 있음을 알기 위해서입니다. 반대로, 하루에 티켓이 없는 경우 continue 이벤트를 사용하여 다음 날짜 인스턴스를 확인합니다. Boolean 변수의 결과를 이 규칙의 반환 값으로 사용합니다. 최종 결과는 다음과 같아야 합니다:
![image](https://github.com/user-attachments/assets/32c8c5f4-cc1f-442c-a68c-639d4ac86e79)

### 4.5 마이크로플로
#### 4.5.1 마이크로플로우 설계 단계 
이제 마이크로플로우로 돌아가서, 부정적인 결과를 처리해보겠습니다. 
1. 이 경우, 사용자에게 친절한 메시지를 알려야 합니다. 이는 규칙 내에서 할 수 없는 일이므로, 마이크로플로우에서 수행해야 합니다. 정보 유형의 메시지 표시 활동을 사용하여 "불행하게도 이 이벤트의 티켓은 매진되었습니다."와 같은 친절한 메시지를 제공합니다. 유효성 검사가 긍정적이라면, 실제로 등록 프로세스를 시작할 수 있습니다.
2. 프로세스를 위한 정보는 Registration 객체를 생성하고, 사용자가 세부정보를 입력할 수 있는 페이지를 표시해야 합니다. 페이지에서는 사용자의 정보를 요청하는 논리적인 설정을 만들 수 있습니다.
3. 사용자가 정보를 입력하면 모든 정보가 올바르게 입력되었는지 확인해야 합니다.
4. 기본 저장 버튼을 변경하여 마이크로플로우를 호출하고, 마이크로플로우 이름을 `ACT_Registration_FinishSignUpForTickets`로 설정합니다.
5. 이 마이크로플로우에서 유효성 검사를 수행하는 마이크로플로우를 호출합니다. 이 유효성 검사 서브 마이크로플로우는 필수 필드와 종속성에 대해 두 개의 서브 마이크로플로우를 호출합니다.
6. 필수 유효성 검사에서 다음 사항을 확인해야 합니다:
  - Firstname이 입력되었는지
  - Lastname이 입력되었는지
  - Email이 입력되었는지
  - Date of birth가 입력되었는지
  - Password가 입력되었는지

1. 종속성에 대해서는 등록 시점에 사용자가 18세 이상인지 확인합니다. 다음 표현식을 사용할 수 있습니다: `addYearsUTC($Registration/DateOfBirth, 18) < [%BeginOfCurrentDay%]`.
2. 주요 유효성 검사 마이크로플로우를 생성하고, 그 결과를 사용하여 사용자가 등록 프로세스를 계속 진행할 수 있는지 여부를 결정합니다.
![image](https://github.com/user-attachments/assets/963d8813-12a0-4b63-83de-d982f56737a2)

1. 등록을 진행할 수 없다면, 종료 이벤트로 이동합니다. 이렇게 하면 마이크로플로우가 종료되고 유효성 검사 마이크로플로우에서 유효성 검사 메시지가 표시됩니다.
2. 등록을 진행할 수 있다면, 다음 단계는 방문자의 사용자 역할을 검색하는 것입니다. 우리는 단일 사용자 역할만 검색하며, 목록이 아닙니다. 다음 Xpath를 사용하세요: `[id = ‘[%UserRole_Visitor%]’]`.
3. 다음 단계는 이 사람을 위한 언어를 검색하는 것입니다. 이 앱에는 단일 언어만 구성되어 있으므로, Language 엔터티에서 첫 번째 항목을 검색합니다.
4. 이제 새 Visitor 객체를 설정하는 데 필요한 모든 정보가 있습니다.
5. 그러나 객체를 생성해야 합니다. 다음 정보를 설정합니다:
![image](https://github.com/user-attachments/assets/b544f9ec-3107-4de9-b643-7d99bab3b0e3)

세 가지 더 추가하고 완료합니다!
1. Registration 객체를 롤백하여 우리가 필요한 모든 것을 복사했으므로 Registration 객체를 저장하고 싶지 않음을 표시합니다. 롤백 작업은 이 객체에 대해 무엇을 하고 싶은지 고려했음을 보여주므로 추가하는 것이 좋습니다.
2. 등록 페이지를 닫고 "등록해 주셔서 감사합니다! 행사장에서 뵙기를 기대합니다."와 같은 친절한 메시지를 표시합니다.
![image](https://github.com/user-attachments/assets/58430146-f644-429a-a712-00c168a293b6)

이제 테스트를 하고 싶지만, 먼저 보안 오류를 해결해야 합니다. 이에 따라 수정해 주세요.
이제 작동하는지 테스트하고, 이메일 주소와 제공된 비밀번호로 로그인해 보세요. 그러나 모든 사용자가 익명 홈페이지만 보게 되어 로그인할 수 있는 곳이 없다는 점을 기억하세요. 현재로서는 앱 URL(http://localhost:8080/index.html)로 가서 index.html 부분을 제거하고 login.html로 교체하여 로그인 양식을 볼 수 있습니다.

# 마이크로플로우 디버깅
## 1. 디버거? 
### 1.1 디버거란 무엇인가?
- Mendix Studio Pro에는 애플리케이션에 기술적 오류가 있는지 검증하는 내장 일관성 검사기가 있습니다.
- 이러한 기술적 오류는 오류 창에서 확인할 수 있으며, 애플리케이션을 배포하기 전에 해결해야 합니다.
- 이 기능은 런타임 중 기술적 오류를 크게 줄여주지만, Mendix Studio Pro는 애플리케이션에 기능적 오류가 있는지 자동으로 확인할 수는 없습니다.
- 애플리케이션이 예상대로 기능적으로 동작하는지 확인하기 위해 Mendix 플랫폼은 디버거 도구를 제공합니다.

### 1.2 디버거 사용하기
- 디버거는 애플리케이션의 실행을 일시 중지하고 앱 변수의 상태를 검사하며, 마이크로플로우가 이를 어떻게 작용하는지 확인할 수 있도록 돕습니다.
- 또한, Mendix Cloud 또는 다른 원격 서버에서 실행 중인 애플리케이션을 원격으로 디버깅할 수 있습니다.

### 1.3 디버거 사용 시기
런타임 오류의 근본 원인을 수동으로 조사하고 스택 추적을 읽어도 찾을 수 없을 때 디버거를 사용해야 합니다. 또한, 마이크로플로우의 결과가 예상과 다를 때도 디버거를 사용해야 합니다.

### 1.4 가장 일반적인 시나리오
#### 1.4.1 애플리케이션 런타임 오류
애플리케이션 사용자가 애플리케이션에서 오류를 경험하는 경우:
![image](https://github.com/user-attachments/assets/dce30090-461d-4e42-b506-649cb7edf632)
예를 들어, 웹 서비스를 호출할 때 웹 서비스 출력 처리 중 오류가 발생할 수 있습니다. 이 경우 오류의 원인을 찾기 어려울 수 있습니다. 데이터 오류(1) 때문인지, 출력 처리 중 오류(2) 때문인지 확인해야 합니다.

이런 경우, 반환된 데이터 세트를 조사하여 어떤 요소가 마이크로플로우를 중단시키는지 추적하는 것이 유용합니다. 따라서 Call Web Service 활동에 중단점을 추가하여 마이크로플로우가 해당 서브 마이크로플로우를 실행하기 전에 일시 중지하도록 설정합니다. 이후 각 단계의 결과를 조사하며 나머지 활동을 단계별로 진행할 수 있습니다.

#### 1.4.2 예상치 못한 동작
마이크로플로우의 결과가 예상과 다를 때, 원인을 찾기가 어려울 수 있습니다.  
예를 들어, 아래 마이크로플로우의 예상 결과는 OrderDate + 3일의 배송 날짜입니다. 그러나 반환된 배송 날짜는 OrderDate + 2일입니다. 이런 경우, 데이터 오류(1), Ordered before 4PM 독점 분기에서의 결정 오류(2), 두 번째 독점 분기에서의 오류(3), 또는 Change Variable 활동 중의 오류(4)인지 확인해야 합니다.
![image](https://github.com/user-attachments/assets/e976169c-f18d-43ae-b03b-de08167bfde4)

마이크로플로우를 디버깅하면 마이크로플로우 시작 시점의 데이터, 독점 분기의 결과 및 마이크로플로우를 따라간 경로를 조사할 수 있습니다. 반환된 데이터 세트가 예상 데이터 세트와 일치하지 않는 경우, 마이크로플로우 내의 제약 조건 문제, 사용된 변수 또는 보안 규칙이 추가 제약 조건을 유발했는지 확인해야 합니다.
![image](https://github.com/user-attachments/assets/2628aa5e-f1bc-4163-9245-b1f5906d7464)

### 1.5 조건에 따른 디버거 설정
#### 조건부 디버거
때때로 특정 조건이 충족될 때만 마이크로플로우가 일시 중지되도록 중단점을 구성해야 할 필요가 있습니다. 이를 통해 마이크로플로우 표현식을 사용하여 중단점 조건을 설정할 수 있습니다.

#### 객체 값 조건
중단점 조건을 설정하면 배치 프로세스를 디버깅할 때 특정 값에서만 중단할 수 있습니다. 이 조건을 사용하면 스텝을 거쳐야 할 반복 횟수를 줄일 수 있습니다.

#### 사용자 값 조건
![image](https://github.com/user-attachments/assets/ac8120f3-a080-4dea-87c5-fba9affff2c0)
$CurrentUser 변수를 기반으로 조건을 설정할 수도 있습니다. 이 조건을 사용하면 특정 사용자가 마이크로플로우를 사용할 때만 일시 중지됩니다. 생산 환경에서 실행 중인 애플리케이션을 디버깅할 때 이 중단점 조건을 사용하는 것이 강력히 권장됩니다. 이는 다른 사용자에게 중단되는 것을 방지할 수 있습니다.
예: `$currentUser/Name = ‘MendixUser’`
![image](https://github.com/user-attachments/assets/3467a53a-3ad4-45c2-93bc-2efae16bebd4)
조건부 디버깅을 활성화하는 방법에 대한 자세한 내용은 “Breakpoint Conditions” 섹션을 참조하세요.

### 1.6 원격 디버깅
Mendix 플랫폼의 가장 강력한 자산 중 하나는 원격으로 디버깅할 수 있는 기능입니다. Mendix Studio Pro의 디버깅 기능을 Mendix Cloud 또는 다른 원격 서버에서 실행 중인 애플리케이션 인스턴스에 연결할 수 있습니다.

원격 서버에서 디버깅해야 하는 많은 시나리오가 있습니다. 예를 들어, 로컬에서 애플리케이션을 실행할 때 사용되는 통합이 없을 수 있습니다. 또한, 테스트/승인 환경에서 테스트할 때 통합이 프로덕션 환경과 다른 응답을 반환하는 경우가 많습니다. 마지막으로, 로컬에서 문제를 재현할 수 없는 경우도 있습니다.
![image](https://github.com/user-attachments/assets/187c29a6-351a-43c5-b742-e3ab38c94fcb)

원격 디버깅을 통해 마이크로플로우를 그 컨텍스트와 필요한 데이터 세트를 가지고 디버깅할 수 있습니다. 모델러 디버거 창에서 서버에서 제공하는 자격 증명을 사용하여 원격 서버에 디버거를 연결할 수 있습니다.

원격 애플리케이션에 연결할 때 중단점을 추가하면 이 중단점이 직접 활성화되지 않는 점에 유의해야 합니다. 수동으로 활성화해야 합니다. 그렇지 않으면 원하지 않는 프로세스를 중단할 수 있습니다. 원격 디버깅을 활성화하는 방법 및 작업 방법에 대한 자세한 내용은 How to Debug Microflows Remotely를 참조하세요.

## 2. 결함 찾기
### 2.1 디버깅 위치
- 디버깅을 시작하기 위해 우리는 중단점을 위한 좋은 위치를 찾아야 합니다. 마이크로플로우의 어디에 배치할까요?
- 가장 쉽고 신뢰할 수 있는 방법은 프로세스의 시작 부분에 직접 설정하는 것입니다.
  - 이렇게 하면 전체 프로세스를 단계별로 진행할 수 있습니다.
  - 문제가 어디에 있을지 더 잘 알고 있다면 프로세스의 더 먼 부분에 중단점을 배치할 수도 있습니다.

1. 우리의 경우, 검증 후 첫 번째 활동에 중단점을 둘 수 있습니다. 이유가 검증 과정에 없다고 생각하기 때문입니다.
![image](https://github.com/user-attachments/assets/bf39e6d9-6b7e-49e2-bcfa-3d125f3e6072)

1. 추가한 중단점을 사용하기 위해 마이크로플로우를 트리거해야 합니다. 기억하시겠지만, 이 마이크로플로우는 등록을 저장할 때 트리거됩니다. 동작을 트리거하고 중단점이 마이크로플로우를 일시 정지시키는 모습을 확인하세요. 디버거 도크에서 현재 하나의 프로세스가 일시 정지된 것을 볼 수 있습니다.
2. 가용 데이터의 값을 직접 보기 위해 변수 도크의 위치를 변경하여 마이크로플로우 단계를 제어하고 변수를 볼 수 있는 것이 가장 좋습니다.
3. 변수 도크에서 변수를 확장하고 축소하여 결함이 있는 위치를 추론할 수 있는 추가 정보를 확인할 수 있습니다. 등록 객체는 모든 것이 괜찮지만, NewVisitor 객체가 흥미로울 수 있으므로 그 쪽으로 이동해 봅시다.
![image](https://github.com/user-attachments/assets/578e9e09-65e6-4260-b786-d48fd9a3baa4)

1. 디버거 동작 "다음 단계로 이동"을 사용하여 마이크로플로우의 다음 단계로 이동할 수 있습니다. 변수 도크는 중단점이 위치한 시점까지의 모든 정보를 보여줍니다. 따라서 현재 디버거가 위치한 활동의 정보는 포함되지 않습니다.

"다음 단계로 이동" 버튼을 3번 사용하여 디버거가 롤백 활동에 도달할 때까지 진행하세요.

우리가 보는 것은 NewVisitor 객체의 상태가 '인스턴스화됨'이라는 값입니다. 이는 객체가 아직 저장되지 않았음을 의미합니다. 따라서 현재 등록하는 사용자에 대한 계정이 생성되지 않았습니다. NewVisitor 객체를 생성하고 변경하는 활동을 살펴봅시다. 열어보면 커밋을 잊은 것을 알 수 있습니다. 이를 커밋하도록 변경하세요.

이제 디버거 동작 "계속"을 사용하여 나머지 마이크로플로우를 실행할 수 있습니다. 중단점을 제거하고 페이지 닫기 활동에 새 중단점을 놓습니다. 새 기능을 사용하기 위해 앱을 재시작하고 모든 것이 잘 진행되는지 확인합니다.

이제 모든 것이 잘 작동하며, 새로운 사용자로 로그인할 수 있습니다. 멋지네요!

# 퀴즈
## Question 1: 
How can you allow users to access parts of an app (like a login page) without needing to log in?
- **Set up anonymous users.**

### 한글 번역:
앱의 일부(예: 로그인 페이지)에 로그인하지 않고 접근할 수 있게 하려면 어떻게 해야 합니까?
- **익명 사용자 설정하기.**

### 오답 해설:
- **Relax security for whichever pages need to be accessed**: 페이지의 보안을 완화하는 것은 앱의 보안성을 떨어뜨리고, 익명 사용자가 아닌 불특정 다수가 접근할 수 있어 위험할 수 있습니다.
- **Set up trial users**: 체험 사용자 설정은 로그인 없이 접근하는 방법이 아니며, 로그인 후 일정 기간 동안만 사용 권한을 부여하는 방식입니다.
- **Set account security accordingly**: 계정 보안 설정을 조정하는 것은 로그인 없이 접근을 허용하는 방법이 아닙니다.

### 정답 해설:
- **Set up anonymous users**: 익명 사용자 설정은 Mendix에서 인증 없이 특정 페이지에 접근할 수 있게 해주는 기능입니다. 이는 보안이 필요한 페이지와 그렇지 않은 페이지를 구분하는 데 유용합니다.

---

## Question 2: 
In a microflow, what is a token?
- **A system-generated value.**

### 한글 번역:
마이크로플로우에서 토큰이란 무엇인가요?
- **시스템에서 생성된 값입니다.**

### 오답 해설:
- **A placeholder variable defined by the developer**: 토큰은 개발자가 정의한 변수의 자리 표시자가 아닙니다. 이는 시스템에서 생성된 고유한 값입니다.
- **A value determining how many sub-microflows may be called in the current microflow**: 토큰은 서브 마이크로플로우의 호출 횟수를 결정하는 값이 아닙니다.
- **A hash string used in user account validation**: 해시 문자열은 보통 사용자 계정 검증에 사용되지만, 토큰과는 다릅니다.

### 정답 해설:
- **A system-generated value**: 토큰은 시스템에서 생성되는 고유한 값으로, 특정 프로세스나 세션을 식별하는 데 사용됩니다. 이는 주로 인증이나 보안과 관련된 컨텍스트에서 많이 사용됩니다.

---

## Question 3: 
In a microflow expression, “toUpperCase” is an example of what?
- **A function.**

### 한글 번역:
마이크로플로우 표현식에서 “toUpperCase”는 무엇의 예인가요?
- **함수**입니다.

### 오답 해설:
- **A string transform**: 문자열 변환(transform)은 결과적으로 대문자로 바뀌지만, 변환 자체가 아니라 이는 함수로 구현됩니다.
- **A cast**: 캐스트는 데이터 타입을 변환하는 것으로, 대문자 변환과는 관련이 없습니다.
- **An operation**: 연산(operation)은 수학적 또는 논리적 처리를 의미하며, 문자열 변환과는 다릅니다.

### 정답 해설:
- **A function**: “toUpperCase”는 문자열을 대문자로 변환하는 함수입니다. 이와 같은 함수는 마이크로플로우에서 데이터를 처리할 때 사용됩니다.

---

## Question 4: 
In a microflow, what would be an example of a variable?
- **$Customer.**

### 한글 번역:
마이크로플로우에서 변수의 예는 무엇인가요?
- **$Customer**입니다.

### 오답 해설:
- **Round**: Round는 숫자를 반올림하는 함수입니다. 변수는 아닙니다.
- **Empty**: Empty는 특정 값이 비어 있는지 확인하는 표현식일 수 있지만, 변수는 아닙니다.
- **formatDateTime**: formatDateTime은 날짜 및 시간을 형식화하는 함수로, 변수는 아닙니다.

### 정답 해설:
- **$Customer**: $로 시작하는 표현은 변수입니다. 마이크로플로우에서는 변수로 데이터를 저장하고 처리할 수 있습니다.

---

## Question 5: 
You need to debug a microflow in production but don’t want to impact your users. How can you trigger debugging only when you personally are running the microflow?
- **Set a breakpoint condition.**

### 한글 번역:
프로덕션에서 마이크로플로우를 디버깅해야 하지만 사용자에게 영향을 미치지 않으려면 어떻게 해야 합니까? 
- **중단점 조건을 설정합니다.**

### 오답 해설:
- **Add a decision to the microflow**: 마이크로플로우에 결정을 추가하는 것은 디버깅 조건을 설정하는 방법이 아닙니다.
- **Adjust security accordingly**: 보안을 조정하는 것은 특정 사용자에게만 디버깅을 트리거하는 방법이 아닙니다.
- **Write a microflow expression**: 마이크로플로우 표현식만으로는 디버깅을 개인적으로 트리거할 수 없습니다.

### 정답 해설:
- **Set a breakpoint condition**: 중단점 조건을 사용하면 특정 사용자(예: 현재 사용자)에게만 디버깅이 트리거되도록 할 수 있습니다. 이는 프로덕션 환경에서 다른 사용자에게 영향을 주지 않고 디버깅할 때 매우 유용합니다.
